        - using StaticArrays,SatelliteToolbox,Dates
        - 
        - # Julian date calculation
        - 
        - jd(Y, M, D, h, m, s) = 1721013.5 + 367 * Y - trunc(7 / 4 * (Y + trunc((M + 9) / 12))) + trunc(275 * M / 9) + D + (60 * h + m + s / 60) / 1440
        - jd(t::DateTime) = jd(Dates.year(t),Dates.month(t),Dates.day(t),Dates.hour(t),Dates.minute(t),Dates.second(t)+Dates.millisecond(t))
        - date_to_jd(t::DateTime) = SatelliteToolbox.date_to_jd(Dates.year(t),Dates.month(t),Dates.day(t),Dates.hour(t),Dates.minute(t),Dates.second(t)+Dates.millisecond(t))
        - function Base.length(in::DateTime)
        -     return 0
        - end
        - 
        - #=
        - function eci_to_ecef(epoch)
        -     @unpack Y, M, D, h, m, s = epoch
        -     # Number of julian centuries elapsed from the epoch j2000.0 to zero hours of the date in question
        -     T0 = (jd(Y, M, D, 0, 0, 0) - 2451545) / 36525
        - 
        -     # Greenwich Mean Sidereal Time angle
        -     θGMST = ((24110.54841 + 8640184.812866 * T0 + 0.093104 * T0^2 - 6.2e-6 * T0^3 + 1.002737909350795 * (3600 * h + 60 * m + s)) % 86400) / 240 #2.70
        - 
        -     R_EciToEcef = @SMatrix [
        -         cos(θGMST) sin(θGMST) 0
        -         -sin(θGMST) cos(θGMST) 0
        -         0 0 1
        -     ]
        -     return R_EciToEcef
        - end
        - =#
        - # ECEF to Latitude,Longitude,Altitude (LLA)
        - #Markley/Crassidis equations 2.77(a-g)
        - function ecef_to_lla_not_working(r_ecef)
        -     a = 6378137.0 #m
        -     b = 6356752.3142 #m
        -     x, y, z = r_ecef
        -     e² = 1 - b^2 / a^2
        -     ϵ² = a^2 / b^2 - 1
        -     ρ = √(x^2 + y^2)
        -     p = abs(z) / ϵ²
        -     s = ρ^2 / (e² * ϵ²)
        -     q = p^2 - b^2 + s
        -     u = p / √(q)
        -     v = b^2 * u^2 / q
        -     P = 27 * v * s / q
        -     Q = (√(P + 1) + √(P))^(2 / 3)
        -     t = (1 + Q + 1 / Q) / 6
        -     c = √(u^2 - 1 + 2 * t)
        -     w = (c - u) / 2
        -     d = sign(z) * √(q) * (w + (√(t^2 + v) - u * w - t / 2 - 1 / 4)^1 / 2)
        -     N = a * √(1 + ϵ² * d^2 / b^2)
        -     λ = asin((ϵ² + 1) * (d / N)) #latitude
        -     h = ρ * cos(λ) + z * sin(λ) - a^2 / N #altitude
        -     ϕ = atan(y, x) #longitude
        - 
        -     return @SVector [λ, ϕ, h]
        - end
        - 
        - function ecef_to_lla(r_ecef)
        -     # Journal of Geodesy (2002) 76: 451–454
        -     # DOI:10.1007/s00190-002-0273-6
        -     #-----------------------------------------------------
        0     x, y, z = r_ecef
        - 
        -     # geodetic (ellipsoid) parameters (a,f) or (a,e)
        -     # semimajor axis, determined from a combination of Doppler satellite and astro-geodetic data 
        -     # flattening, determined from satellite data
        -     a = 6378137.0 # semimajor axis (6378137 m, WGS84 value)
        -     ecc = 0.0818
        0     b = a * sqrt(1 - ecc^2) # semiminor axis
        -     esq = ecc^2 # eccentricity square; ecc^2 = 2*f - f^2;
        -     # f = 1-b/a; # flattening (1/298.25, WGS84 value)
        - 
        -     # Start 15-step procedure
        0     r = sqrt(x^2 + y^2)
        0     r2 = r^2
        0     b2 = b^2
        -     a2 = a^2
        0     Z2 = z^2
        -     esq2 = esq^2
        0     epsq = (a2 / b2) - 1 # e_prime square
        0     F = 54 * b2 * Z2
        0     G = r2 + (1 - esq) * Z2 - esq * (a2 - b2)
        0     C = (esq2 * F * r2) / (G * G * G)
        0     S = (1 + C + sqrt(C^2 + 2 * C))^(1 / 3)
        0     P = F / (3 * (S + (1 / S) + 1)^2 * G^2)
        0     Q = sqrt(1 + 2 * esq2 * P)
        0     r0Det = 0.5 * a2 * (1 + 1 / Q) - (1 - esq) * P * Z2 / (Q * (1 + Q)) - 0.5 * P * r2
        0     r0 = -esq * P * r / (1 + Q) + sqrt(abs(r0Det))
        0     U = sqrt((r - esq * r0)^2 + Z2)
        0     V = sqrt((r - esq * r0)^2 + (1 - esq) * Z2)
        0     Z0 = b2 * z / (a * V)
        -     # Solution ...
        0     lat = atan((z + epsq * Z0), r)
        0     lon = atan(y, x)
        0     alt = U * (1 - b2 / (a * V))
        0     return @SVector [lat, lon, alt]
        - end
        - 
        - function decyear(epoch)
        -     #  DECYEAR Calculate decimal year.
        -     #   DY = DECYEAR( V ) converts one or more date vectors V into decimal year
        -     #   DY.  Input V can be an M-by-6 or M-by-3 matrix containing M full or
        -     #   partial date vectors respectively.  DECYEAR returns a column vector of
        -     #   M decimal years.
        -     #
        -     #   A date vector contains six elements, specifying year, month, day, hour,
        -     #   minute, and second. A partial date vector has three elements,
        -     #   specifying year, month, and day.  Each element of V must be a positive
        -     #   double precision number.
        -     
        -     leapyear = (((epoch.Y % 4) == 0) & ((epoch.Y % 100) != 0)) | ((epoch.Y % 400)  == 0)
        -     
        -     ndays = leapyear ? 366 : 365
        -     
        -     dayofyear = jd(epoch.Y,epoch.M,epoch.D,0,0,0) - jd(epoch.Y,1,1,0,0,0)
        -     
        -     # calculate the decimal year
        -     dyear = epoch.Y + dayofyear/ndays
        - 
        -     return dyear
        - end
